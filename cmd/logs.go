package cmd

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"github.com/spf13/cobra"

	"github.com/apoxy-dev/apoxy-cli/pretty"
	"github.com/apoxy-dev/apoxy-cli/rest"
)

type accessLog struct {
	Timestamp     string `json:"timestamp"`
	RequestMethod string `json:"request_method"`
	RequestHost   string `json:"request_host"`
	ResponseCode  string `json:"response_code"`
}

type logRecord struct {
	ID        int       `json:"id"`
	Timestamp time.Time `json:"timestamp"`
	Source    string    `json:"source"`
	Message   string    `json:"message"`
}

type logResponse struct {
	Logs  []*logRecord `json:"logs"`
	Total int          `json:"total"`
}

type logResponseChunk struct {
	Result *logRecord `json:"result"`
}

var jsonOutput bool

func printLogsOneShot(c *rest.APIClient, params url.Values) error {
	params.Add("order", "asc")
	resp, err := c.SendRequest(http.MethodGet, "/v1/logs?"+params.Encode(), nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	dec := json.NewDecoder(resp.Body)
	for {
		t, err := dec.Token() // Top-level token.
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}

		if t == "logs" {
			t, err = dec.Token() // [ delimiter.
			if err != nil {
				return err
			}
			if t != json.Delim('[') {
				return fmt.Errorf("unexpected token: %v", t)
			}

			for dec.More() { // Array of logs.
				var lr logRecord
				if err := dec.Decode(&lr); err != nil {
					return err
				}
				if jsonOutput {
					fmt.Printf("%s\n", lr.Message)
				} else {
					pretty.PrintLn(lr.Timestamp, lr.Source, lr.Message)
				}
			}

			t, err = dec.Token() // ] delimiter.
			if err != nil {
				return err
			}
			if t != json.Delim(']') {
				return fmt.Errorf("unexpected token: %v", t)
			}
		}
	}

	return nil
}

func printLogsFollow(c *rest.APIClient, params url.Values) error {
	resp, err := c.SendRequest(http.MethodGet, "/v1/logs/tail?"+params.Encode(), nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	dec := json.NewDecoder(resp.Body)
	for dec.More() {
		var lr logResponseChunk
		if err := dec.Decode(&lr); err != nil {
			return err
		}
		if lr.Result == nil {
			continue
		}
		if jsonOutput {
			fmt.Printf("%s\n", lr.Result.Message)
		} else {
			pretty.PrintLn(lr.Result.Timestamp, lr.Result.Source, lr.Result.Message)
		}
	}

	return nil
}

var logsCmd = &cobra.Command{
	Use:   "logs",
	Short: "View proxy logs",
	Long: `View the request/process logs generated by your proxies.  Logs can be filtered by proxy instance
and/or date range. By default, logs are streamed in real-time.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		proxy, err := cmd.Flags().GetString("proxy")
		if err != nil {
			return err
		}
		follow, err := cmd.Flags().GetBool("follow")
		if err != nil {
			return err
		}
		since, err := cmd.Flags().GetDuration("since")
		if err != nil {
			return err
		}
		sinceTimeS, err := cmd.Flags().GetString("since-time")
		if err != nil {
			return err
		}
		var sinceTime time.Time
		if sinceTimeS != "" {
			sinceTime, err = time.Parse(time.RFC3339, sinceTimeS)
			if err != nil {
				return fmt.Errorf("invalid time format (expecting RFC3999): %s", sinceTimeS)
			}
		}
		if since != 0 && !sinceTime.IsZero() {
			return fmt.Errorf("only one of --since and --since-time can be specified")
		}

		cmd.SilenceUsage = true

		c, err := defaultAPIClient()
		if err != nil {
			return err
		}

		params := url.Values{}
		if proxy != "" {
			params.Add("query", fmt.Sprintf("proxy=%q", proxy))
		}
		if since != 0 {
			params.Add("start_time", time.Now().Add(-since).Format(time.RFC3339))
		} else if !sinceTime.IsZero() {
			params.Add("start_time", sinceTime.Format(time.RFC3339))
		}

		if follow {
			return printLogsFollow(c, params)
		} else {
			return printLogsOneShot(c, params)
		}
	},
}

func init() {
	logsCmd.PersistentFlags().BoolVar(&jsonOutput, "json", false, "Output in raw JSON format")
	logsCmd.PersistentFlags().StringP("proxy", "p", "", "Proxy name")
	logsCmd.Flags().BoolP("follow", "f", false, "Follow logs in real-time")
	logsCmd.Flags().DurationP("since", "", 0, "Show logs since a given duration (e.g. 5m, 1h)")
	logsCmd.Flags().StringP("since-time", "", "", "Show logs from a given date (e.g. 2019-01-01T00:00:00Z)")
	rootCmd.AddCommand(logsCmd)
}
