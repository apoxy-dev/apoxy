package cmd

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/spf13/cobra"

	"github.com/apoxy-dev/apoxy-cli/internal/logs"
	"github.com/apoxy-dev/apoxy-cli/pretty"
	"github.com/apoxy-dev/apoxy-cli/rest"
)

type logRecord struct {
	ID        int       `json:"id"`
	SpanID    int       `json:"spanId"`
	Timestamp time.Time `json:"timestamp"`
	Source    string    `json:"source"`
	Message   string    `json:"message"`
}

type logResponse struct {
	Logs  []*logRecord `json:"logs"`
	Total int          `json:"total"`
}

type logResponseChunk struct {
	Result *logRecord `json:"result"`
}

var jsonOutput bool

func requestLogs(
	c *rest.APIClient,
	params url.Values,
	cb func(*logRecord) error,
) error {
	params.Add("order", "asc")
	resp, err := c.SendRequest(http.MethodGet, "/v1/logs?"+params.Encode(), nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	dec := json.NewDecoder(resp.Body)
	for {
		t, err := dec.Token() // Top-level token.
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}

		if t == "logs" {
			t, err = dec.Token() // [ delimiter.
			if err != nil {
				return err
			}
			if t != json.Delim('[') {
				return fmt.Errorf("unexpected token: %v", t)
			}

			for dec.More() { // Array of logs.
				var lr logRecord
				if err := dec.Decode(&lr); err != nil {
					return err
				}

				if err := cb(&lr); err != nil {
					return err
				}
			}

			t, err = dec.Token() // ] delimiter.
			if err != nil {
				return err
			}
			if t != json.Delim(']') {
				return fmt.Errorf("unexpected token: %v", t)
			}
		}
	}

	return nil
}

func printLogsOneShot(c *rest.APIClient, params url.Values) error {
	return requestLogs(c, params, func(lr *logRecord) error {
		if jsonOutput {
			fmt.Printf("%s\n", lr.Message)
		} else {
			pretty.PrintLn(lr.Timestamp, lr.ID, lr.SpanID, lr.Source, lr.Message)
		}
		return nil
	})
}

func printLogsFollow(c *rest.APIClient, params url.Values) error {
	resp, err := c.SendRequest(http.MethodGet, "/v1/logs/tail?"+params.Encode(), nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	dec := json.NewDecoder(resp.Body)
	for dec.More() {
		var lr logResponseChunk
		if err := dec.Decode(&lr); err != nil {
			return err
		}
		if lr.Result == nil {
			continue
		}
		if jsonOutput {
			fmt.Printf("%s\n", lr.Result.Message)
		} else {
			pretty.PrintLn(lr.Result.Timestamp, lr.Result.ID, lr.Result.SpanID, lr.Result.Source, lr.Result.Message)
		}
	}

	return nil
}

func tuiProgram(c *rest.APIClient, follow bool, params url.Values) error {
	lm := map[int]*logs.LogRecord{}
	if err := requestLogs(c, params, func(lr *logRecord) error {
		if lr.SpanID == 0 {
			lm[lr.ID] = &logs.LogRecord{
				Timestamp:  lr.Timestamp,
				Source:     lr.Source,
				RawMessage: lr.Message,
			}
		} else if r, ok := lm[lr.SpanID]; ok {
			r.Spans = append(r.Spans, &logs.LogRecord{
				Timestamp:  lr.Timestamp,
				Source:     lr.Source,
				RawMessage: lr.Message,
			})
		}
		return nil
	}); err != nil {
		return err
	}
	var ls []*logs.LogRecord
	for _, l := range lm {
		ls = append(ls, l)
	}

	p := tea.NewProgram(logs.NewModel(ls, follow, nil))
	if _, err := p.Run(); err != nil {
		return err
	}
	return nil
}

var logsCmd = &cobra.Command{
	Use:   "logs",
	Short: "View proxy logs",
	Long: `View the request/process logs generated by your proxies.  Logs can be filtered by proxy instance
and/or date range. By default, logs are streamed in real-time.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		proxy, err := cmd.Flags().GetString("proxy")
		if err != nil {
			return err
		}
		follow, err := cmd.Flags().GetBool("follow")
		if err != nil {
			return err
		}
		since, err := cmd.Flags().GetDuration("since")
		if err != nil {
			return err
		}
		sinceTimeS, err := cmd.Flags().GetString("since-time")
		if err != nil {
			return err
		}
		var sinceTime time.Time
		if sinceTimeS != "" {
			sinceTime, err = time.Parse(time.RFC3339, sinceTimeS)
			if err != nil {
				return fmt.Errorf("invalid time format (expecting RFC3999): %s", sinceTimeS)
			}
		}
		if since != 0 && !sinceTime.IsZero() {
			return fmt.Errorf("only one of --since and --since-time can be specified")
		}

		enableTUI, err := cmd.Flags().GetBool("tui")
		if err != nil {
			return err
		}

		cmd.SilenceUsage = true

		c, err := defaultAPIClient()
		if err != nil {
			return err
		}

		params := url.Values{}
		if proxy != "" {
			params.Add("query", fmt.Sprintf("proxy=%q", proxy))
		}
		if since != 0 {
			params.Add("start_time", time.Now().Add(-since).Format(time.RFC3339))
		} else if !sinceTime.IsZero() {
			params.Add("start_time", sinceTime.Format(time.RFC3339))
		}

		if enableTUI {
			return tuiProgram(c, follow, params)
		} else if follow {
			return printLogsFollow(c, params)
		} else {
			return printLogsOneShot(c, params)
		}
	},
}

func init() {
	logsCmd.PersistentFlags().BoolVar(&jsonOutput, "json", false, "Output in raw JSON format")
	logsCmd.PersistentFlags().StringP("proxy", "p", "", "Proxy name")
	logsCmd.Flags().BoolP("follow", "f", false, "Follow logs in real-time")
	logsCmd.Flags().DurationP("since", "", 0, "Show logs since a given duration (e.g. 5m, 1h)")
	logsCmd.Flags().StringP("since-time", "", "", "Show logs from a given date (e.g. 2019-01-01T00:00:00Z)")
	logsCmd.Flags().BoolP("tui", "", false, "Enable TUI mode")
	rootCmd.AddCommand(logsCmd)
}
